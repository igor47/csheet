[tools]
bun = "1.3.1"
jj = "latest"
dbmate = "2.28.0"
jq = "latest"
pulumi = "3.203.0"

[env]
# Optional: Set default port
PORT = "3000"
GCP_PROJECT = "csheet-475917"
GCP_REGION = "us-central1"
GCR_REPOSITORY = "csheet"
GCR_REGION = "us-central1"
RIPGREP_CONFIG_PATH = "{{config_root}}/.ripgreprc"

[tasks."app:dev"]
run = "bun run --watch main.ts"
description = "Start development server with hot reload"
depends = ["deps:up", "s3:setup"]

[tasks."app:prod"]
run = "NODE_ENV=production bun run main.ts"
description = "Start production server"

[tasks."app:container"]
run = "docker compose --profile app up --build app"
description = "Build and run the app container alongside local deps"
depends = ["s3:setup"]

[tasks."infra:preview"]
run = "pulumi preview --cwd pulumi/infra \"$@\""
description = "Preview infrastructure changes"

[tasks."infra:up"]
run = "pulumi up --cwd pulumi/infra \"$@\""
description = "Apply infrastructure changes"

[tasks."infra:destroy"]
run = "pulumi destroy --cwd pulumi/infra \"$@\""
description = "Destroy provisioned infrastructure"

[tasks."deploy:push"]
run = """
  set -eu
  SHORT_SHA=$(bin/get-commit-sha.sh)
  IMAGE="us-central1-docker.pkg.dev/${GCP_PROJECT}/${GCR_REPOSITORY}/csheet:${SHORT_SHA}"
  echo "Building image ${IMAGE} for commit ${SHORT_SHA}"
  docker build -t "${IMAGE}" .
  echo "Pushing image ${IMAGE}"
  docker push "${IMAGE}"
  echo ""
  echo "Image pushed successfully!"
  echo "To deploy, run: mise run deploy:up"
"""
description = "Build and push the application image to Artifact Registry (tagged with commit SHA)"

[tasks."deploy:preview"]
run = """
  set -eu
  SHORT_SHA=$(bin/get-commit-sha.sh)
  pulumi preview --cwd pulumi/app --config imageTag=${SHORT_SHA} "$@"
"""
description = "Preview application deployment changes with current commit SHA"

[tasks."deploy:up"]
run = """
  set -eu
  SHORT_SHA=$(bin/get-commit-sha.sh)
  pulumi up --cwd pulumi/app --config imageTag=${SHORT_SHA} "$@"
"""
description = "Deploy the Cloud Run service and migration job with current commit SHA"

[tasks."deploy:destroy"]
run = "pulumi destroy --cwd pulumi/app \"$@\""
description = "Remove the Cloud Run service and migration job"

[tasks."ops:logs"]
run = "gcloud beta run services logs tail prod-app --project=csheet-475917 --region=us-central1"
description = "Tail production Cloud Run logs"

[tasks.install]
run = "bun install"
description = "Install dependencies"

[tasks."deps:up"]
run = "docker compose up --detach --wait"
description = "Start all Docker services (PostgreSQL and MinIO)"

[tasks."deps:down"]
run = "docker compose down"
description = "Stop all Docker services"

[tasks."db:upgrade"]
run = """
  CONFIG=$(bun src/config.ts)
  PG_HOST=$(echo "$CONFIG" | jq -r '.postgresHost')
  PG_PORT=$(echo "$CONFIG" | jq -r '.postgresPort')
  PG_USER=$(echo "$CONFIG" | jq -r '.postgresUser')
  PG_PASSWORD=$(echo "$CONFIG" | jq -r '.postgresPassword')
  PG_DB=$(echo "$CONFIG" | jq -r '.postgresDb')
  DATABASE_URL="postgres://$PG_USER:$PG_PASSWORD@$PG_HOST:$PG_PORT/$PG_DB?sslmode=disable" DBMATE_MIGRATIONS_DIR="./migrations" DBMATE_SCHEMA_FILE="./db/schema.sql" dbmate migrate
"""
description = "Run database migrations (common task)"

[tasks.dbmate]
run = """
  CONFIG=$(bun src/config.ts)
  PG_HOST=$(echo "$CONFIG" | jq -r '.postgresHost')
  PG_PORT=$(echo "$CONFIG" | jq -r '.postgresPort')
  PG_USER=$(echo "$CONFIG" | jq -r '.postgresUser')
  PG_PASSWORD=$(echo "$CONFIG" | jq -r '.postgresPassword')
  PG_DB=$(echo "$CONFIG" | jq -r '.postgresDb')
  DATABASE_URL="postgres://$PG_USER:$PG_PASSWORD@$PG_HOST:$PG_PORT/$PG_DB?sslmode=disable" DBMATE_MIGRATIONS_DIR="./migrations" DBMATE_SCHEMA_FILE="./db/schema.sql" dbmate "$@"
"""
description = "Run dbmate commands (new, rollback, status, dump, etc.)"

[tasks."db:psql"]
run = """
  CONFIG=$(bun src/config.ts)
  PG_HOST=$(echo "$CONFIG" | jq -r '.postgresHost')
  PG_PORT=$(echo "$CONFIG" | jq -r '.postgresPort')
  PG_USER=$(echo "$CONFIG" | jq -r '.postgresUser')
  PG_PASSWORD=$(echo "$CONFIG" | jq -r '.postgresPassword')
  PG_DB=$(echo "$CONFIG" | jq -r '.postgresDb')
  PGPASSWORD="$PG_PASSWORD" psql -h "$PG_HOST" -p "$PG_PORT" -U "$PG_USER" -d "$PG_DB"
"""
description = "Open PostgreSQL shell"

[tasks."db:logs"]
run = "docker compose logs -f postgres"
description = "View PostgreSQL container logs"

[tasks.check]
run = """
  echo "Running Biome checks..."
  bun biome check src/ pulumi/
  echo "Running TypeScript checks..."
  bun tsc --noEmit
"""
description = "Check code formatting, linting, and types"

[tasks.check-fix]
run = """
  echo "Running Biome fixes..."
  bun biome check --write src/ pulumi/
  echo "Running TypeScript checks..."
  bun tsc --noEmit
"""
description = "Auto-fix formatting and linting issues, then check types"

[tasks."db:test:create"]
run = """
  CONFIG=$(bun src/config.ts)
  PG_HOST=$(echo "$CONFIG" | jq -r '.postgresHost')
  PG_PORT=$(echo "$CONFIG" | jq -r '.postgresPort')
  PG_USER=$(echo "$CONFIG" | jq -r '.postgresUser')
  PG_DB_TEST=$(echo "$CONFIG" | jq -r '.postgresDbTest')
  export PGPASSWORD=$(echo "$CONFIG" | jq -r '.postgresPassword')

  # Safety check: only allow dropping databases ending in _test
  if [[ ! "$PG_DB_TEST" =~ _test$ ]]; then
    echo "ERROR: Refusing to drop database '$PG_DB_TEST' - must end with '_test' for safety"
    exit 1
  fi

  PSQL_CMD="psql -h $PG_HOST -p $PG_PORT -U $PG_USER -d postgres"
  # Drop database if exists, then create fresh
  $PSQL_CMD -c "DROP DATABASE IF EXISTS $PG_DB_TEST"
  $PSQL_CMD -c "CREATE DATABASE $PG_DB_TEST"
"""
description = "Drop and recreate test database (ensures clean state)"
depends = ["deps:up"]

[tasks."db:test:migrate"]
run = """
  CONFIG=$(bun src/config.ts)
  PG_HOST=$(echo "$CONFIG" | jq -r '.postgresHost')
  PG_PORT=$(echo "$CONFIG" | jq -r '.postgresPort')
  PG_USER=$(echo "$CONFIG" | jq -r '.postgresUser')
  PG_PASSWORD=$(echo "$CONFIG" | jq -r '.postgresPassword')
  PG_DB_TEST=$(echo "$CONFIG" | jq -r '.postgresDbTest')
  DATABASE_URL="postgres://$PG_USER:$PG_PASSWORD@$PG_HOST:$PG_PORT/$PG_DB_TEST?sslmode=disable" DBMATE_MIGRATIONS_DIR="./migrations" DBMATE_NO_DUMP_SCHEMA=true dbmate migrate
"""
description = "Run migrations on test database"
depends = ["db:test:create"]

[tasks."s3:setup"]
run = """
  CONFIG=$(bun src/config.ts)
  S3_BUCKET=$(echo "$CONFIG" | jq -r '.s3BucketName')
  S3_ACCESS_KEY=$(echo "$CONFIG" | jq -r '.s3AccessKeyId')
  S3_SECRET_KEY=$(echo "$CONFIG" | jq -r '.s3SecretAccessKey')

  # Configure MinIO client and create dev bucket
  docker exec csheet_minio mc alias set myminio http://localhost:9000 "$S3_ACCESS_KEY" "$S3_SECRET_KEY" || true
  docker exec csheet_minio mc mb "myminio/$S3_BUCKET" --ignore-existing || true
"""
description = "Create S3 dev bucket in MinIO"
depends = ["deps:up"]

[tasks."s3:test:setup"]
run = """
  CONFIG=$(bun src/config.ts)
  S3_BUCKET_TEST=$(echo "$CONFIG" | jq -r '.s3BucketNameTest')
  S3_ACCESS_KEY=$(echo "$CONFIG" | jq -r '.s3AccessKeyId')
  S3_SECRET_KEY=$(echo "$CONFIG" | jq -r '.s3SecretAccessKey')

  # Configure MinIO client and create test bucket
  docker exec csheet_minio mc alias set myminio http://localhost:9000 "$S3_ACCESS_KEY" "$S3_SECRET_KEY" || true
  docker exec csheet_minio mc mb "myminio/$S3_BUCKET_TEST" --ignore-existing || true
"""
description = "Create S3 test bucket in MinIO"
depends = ["deps:up"]

[tasks.test]
run = """
  CONFIG=$(bun src/config.ts)
  PG_DB_TEST=$(echo "$CONFIG" | jq -r '.postgresDbTest')
  S3_BUCKET_TEST=$(echo "$CONFIG" | jq -r '.s3BucketNameTest')
  export POSTGRES_DB="$PG_DB_TEST"
  export S3_BUCKET_NAME="$S3_BUCKET_TEST"
  export NODE_ENV="test"
  bun test --randomize --only-failures "$@"
"""
description = "Run tests (pass through arguments to bun test)"
depends = ["db:test:migrate", "s3:test:setup"]
